// Generated by CoffeeScript 2.1.1
(function() {
  var bitcoinSocket, calculateColor, calculateDuration, calculateHeight, calculateWidth, currencies, litecoinSocket, nanoSocket, prices, showBlock, showTx, updatePrices;

  currencies = ['btc', 'eth', 'ltc', 'xrb'];

  prices = {};

  // get current price
  (updatePrices = function() {
    var currencyAPI;
    currencyAPI = 'https://min-api.cryptocompare.com/data/price?fsym=USD&tsyms=';
    $.get(currencyAPI + currencies.join(',').toUpperCase(), function(data) {
      var currency, price, results;
      if (data) {
        results = [];
        for (currency in data) {
          price = data[currency];
          currency = currency.toLowerCase();
          prices[currency] = Math.round(1 / price * 100) / 100;
          results.push($('.' + currency + ' .price').text(prices[currency]));
        }
        return results;
      }
    });
    return setTimeout(updatePrices, 10 * 1000);
  })();

  // litecoin live feed
  litecoinSocket = new WebSocket("wss://insight.litecore.io/socket.io/?EIO=3&transport=websocket");

  litecoinSocket.onopen = function() {
    litecoinSocket.send('2probe');
    litecoinSocket.send('5');
    litecoinSocket.send('420["subscribe","sync"]');
    litecoinSocket.send('421["subscribe","inv"]');
    litecoinSocket.send('422["subscribe","sync"]');
    litecoinSocket.send('424["subscribe","sync"]');
    litecoinSocket.send('425["subscribe","inv"]');
    return setInterval((function() {
      return litecoinSocket.send('2');
    }), 25 * 1000);
  };

  litecoinSocket.onmessage = function({data}) {
    var payload, type;
    data = data.match(/^\d+(\[.+?)$/);
    if (data) {
      [type, payload] = JSON.parse(data[1]);
      if (type === 'tx') {
        return showTx('ltc', {
          amount: payload.valueOut,
          fee: 0,
          hash: payload.txid,
          recipients: payload.vout.map(function(value) {
            return Object.keys(value)[0];
          })
        });
      } else {
        return showBlock('ltc', payload);
      }
    }
  };

  // bitcoin live feed
  bitcoinSocket = new WebSocket("wss://ws.blockchain.info/inv");

  bitcoinSocket.onopen = function() {
    bitcoinSocket.send(JSON.stringify({
      op: 'unconfirmed_sub'
    }));
    return bitcoinSocket.send(JSON.stringify({
      op: 'blocks_sub'
    }));
  };

  bitcoinSocket.onmessage = function({data}) {
    var fee, i, input, j, len, len1, output, ref, ref1, valIn, valOut;
    data = JSON.parse(data);
    if (data.op === 'utx') {
      fee = 0;
      valOut = 0;
      valIn = 0;
      ref = data.x.inputs;
      for (i = 0, len = ref.length; i < len; i++) {
        input = ref[i];
        valIn += input.prev_out.value / 100000000;
      }
      ref1 = data.x.out;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        output = ref1[j];
        valOut += output.value / 100000000;
      }
      fee = Math.max(valIn - valOut, 0);
      return showTx('btc', {
        amount: valOut,
        fee: fee,
        recipients: data.x.out.map(function(out) {
          return [out.addr, out.value / 100000000];
        })
      });
    } else {
      return showBlock('btc', data.x);
    }
  };

  // nano live feed
  nanoSocket = new WebSocket("wss://www.nanode.co/socket.io/?EIO=3&transport=websocket");

  nanoSocket.onopen = function() {
    return setInterval((function() {
      return nanoSocket.send('2');
    }), 25 * 1000);
  };

  nanoSocket.onmessage = function({data}) {
    var payload, type;
    data = data.match(/^\d+(\[.+?)$/);
    if (data) {
      [type, payload] = JSON.parse(data[1]);
      if (type === 'block') {
        return showTx('xrb', {
          amount: payload.amount / Math.pow(10, 30),
          fee: 0,
          hash: payload.hash
        });
      }
    }
  };

  // ether live feed
  //etherSocket = new WebSocket "ws://ethersocket.herokuapp.com"
  //etherSocket.onmessage = ({data}) ->
  //  data = JSON.parse data
  //  if data.type is 'tx'
  //    showTx 'eth', {amount: data.ethers, fee: data.fee, hash: data.hash}
  //  else
  //    showBlock 'eth', data

  //###################
  /* calculations */
  //###################
  calculateWidth = function(price) {
    return Math.log10(1 + price) * 10;
  };

  calculateHeight = function(fee) {
    return Math.min(3, Math.log10(1 + fee)) / 3 * 200;
  };

  calculateColor = function(price) {
    var end, percent, result, start;
    percent = Math.min(6, Math.log10(1 + price)) / 6;
    start = [0, 0, 255];
    end = [255, 0, 0];
    result = [start[0] + percent * (end[0] - start[0]), start[1] + percent * (end[1] - start[1]), start[2] + percent * (end[2] - start[2])];
    return '#' + result.map(function(c) {
      return ('0' + Math.round(c).toString(16)).substr(-2);
    }).join('');
  };

  calculateDuration = function(fee) {
    if (fee) {
      return 6000 - Math.round(3000 * Math.min(2, Math.log10(1 + fee)) / 2);
    } else {
      return 3000;
    }
  };

  //################
  /* rendering */
  //################
  showTx = function(currency, tx) {
    var dot, fee, price, size, trail;
    dot = $('<div></div>');
    price = tx.amount * prices[currency];
    fee = tx.fee * prices[currency];
    size = calculateWidth(price);
    dot.css({
      width: size + 'px',
      height: size + 'px',
      backgroundColor: calculateColor(price),
      animationDuration: calculateDuration(fee) + 'ms',
      marginLeft: -1 * size / 2 + 'px',
      left: Math.random() * 100 + '%'
    });
    $('.' + currency + ' .dots').append(dot);
    if (tx.fee) {
      trail = $('<span></span>');
      //    trail.text Math.round(tx.fee * prices[currency]*10)/10
      trail.css({
        height: calculateHeight(fee) + 'px'
      });
      dot.append(trail);
    }
    return setTimeout((function() {
      return dot.remove();
    }), calculateDuration(fee));
  };

  //  console.log 'tx', currency, tx
  showBlock = function(currency, block) {
    console.log(block);
    block = $('<p></p>');
    $('.' + currency + ' .dots').append(block);
    return setTimeout((function() {
      return block.remove();
    }), 5000);
  };

}).call(this);

//# sourceMappingURL=main.js.map
