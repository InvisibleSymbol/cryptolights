// Generated by CoffeeScript 2.2.0
var bitcoinSocket, currencies, etherSocket, lanes, litecoinSocket, nanoSocket, prices, showBlock, showTx, updatePrices;

currencies = ['btc', 'eth', 'ltc', 'xrb'];

prices = {};

// get current price
updatePrices = function() {
  var currencyAPI;
  currencyAPI = 'https://min-api.cryptocompare.com/data/price?fsym=USD&tsyms=';
  $.get(currencyAPI + currencies.join(',').toUpperCase(), function(data) {
    var currency, price, results;
    if (data) {
      results = [];
      for (currency in data) {
        price = data[currency];
        currency = currency.toLowerCase();
        prices[currency] = Math.round(1 / price * 100) / 100;
        results.push($('.' + currency + ' .price').text(prices[currency]));
      }
      return results;
    }
  });
  return setTimeout(updatePrices, 10 * 1000);
};

// litecoin live feed
litecoinSocket = new WebSocket("wss://insight.litecore.io/socket.io/?EIO=3&transport=websocket");

litecoinSocket.onopen = function() {
  litecoinSocket.send('2probe');
  litecoinSocket.send('5');
  litecoinSocket.send('420["subscribe","sync"]');
  litecoinSocket.send('421["subscribe","inv"]');
  litecoinSocket.send('422["subscribe","sync"]');
  litecoinSocket.send('424["subscribe","sync"]');
  litecoinSocket.send('425["subscribe","inv"]');
  return setInterval((function() {
    return litecoinSocket.send('2');
  }), 25 * 1000);
};

litecoinSocket.onmessage = function({data}) {
  var payload, type;
  data = data.match(/^\d+(\[.+?)$/);
  if (data) {
    [type, payload] = JSON.parse(data[1]);
    if (type === 'tx') {
      return showTx('ltc', {
        amount: payload.valueOut,
        fee: 0,
        hash: payload.txid,
        recipients: payload.vout.map(function(value) {
          return Object.keys(value)[0];
        })
      });
    } else {
      return showBlock('ltc', payload);
    }
  }
};

// bitcoin live feed
bitcoinSocket = new WebSocket("wss://ws.blockchain.info/inv");

bitcoinSocket.onopen = function() {
  bitcoinSocket.send(JSON.stringify({
    op: 'unconfirmed_sub'
  }));
  return bitcoinSocket.send(JSON.stringify({
    op: 'blocks_sub'
  }));
};

bitcoinSocket.onmessage = function({data}) {
  var fee, i, input, j, len, len1, output, ref, ref1, valIn, valOut;
  data = JSON.parse(data);
  if (data.op === 'utx') {
    fee = 0;
    valOut = 0;
    valIn = 0;
    ref = data.x.inputs;
    for (i = 0, len = ref.length; i < len; i++) {
      input = ref[i];
      valIn += input.prev_out.value / 100000000;
    }
    ref1 = data.x.out;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      output = ref1[j];
      valOut += output.value / 100000000;
    }
    fee = Math.max(valIn - valOut, 0);
    return showTx('btc', {
      amount: valOut,
      fee: fee,
      recipients: data.x.out.map(function(out) {
        return [out.addr, out.value / 100000000];
      })
    });
  } else {
    return showBlock('btc', data.x);
  }
};

// nano live feed
nanoSocket = new WebSocket("wss://www.nanode.co/socket.io/?EIO=3&transport=websocket");

nanoSocket.onopen = function() {
  return setInterval((function() {
    return nanoSocket.send('2');
  }), 25 * 1000);
};

nanoSocket.onmessage = function({data}) {
  var payload, type;
  data = data.match(/^\d+(\[.+?)$/);
  if (data) {
    [type, payload] = JSON.parse(data[1]);
    if (type === 'block') {
      return showTx('xrb', {
        amount: payload.amount / Math.pow(10, 30),
        fee: 0,
        hash: payload.hash
      });
    }
  }
};

// ether live feed
etherSocket = new WebSocket("ws://ethersocket.herokuapp.com");

etherSocket.onmessage = function({data}) {
  data = JSON.parse(data);
  if (data.type === 'tx') {
    return showTx('eth', {
      amount: data.ethers,
      fee: data.fee,
      hash: data.hash
    });
  } else {
    return showBlock('eth', data);
  }
};

//################
/* rendering */
//################
lanes = {};

showTx = function(currency, tx) {
  var fee, price;
  price = tx.amount * prices[currency];
  fee = tx.fee * prices[currency];
  return lanes[currency].addMeteor({
    speed: fee ? 2 + 4 * Math.min(2, Math.log10(1 + fee)) / 2 : 6,
    hue: price ? 220 - 220 * Math.min(6, Math.log10(1 + price)) / 6 : 220,
    thickness: Math.max(5, Math.log10(1 + price) * 10),
    length: Math.min(3, Math.log10(1 + fee)) / 3 * 250
  });
};

showBlock = function(currency) {
  return lanes[currency].addBlock();
};

$(function() {
  updatePrices();
  return $('.currencies > div').each(function() {
    var canvas, currency;
    currency = $(this).attr('class');
    canvas = $('<canvas></canvas>');
    $('.' + currency).append(canvas);
    return lanes[currency] = new CanvasRenderer(canvas.get(0));
  });
});

//# sourceMappingURL=main.js.map
